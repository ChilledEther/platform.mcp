---
phase: 02-platform-cli
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [cmd/platform/generate.go, cmd/platform/generate_test.go, internal/templates/config.go, internal/templates/templates.yaml]
autonomous: true
---

<objective>
Wire the `generate` command to the core scaffolding logic and externalize template configuration.

Purpose: Connect the CLI user interface to the business logic and ensure templates are configurable without code changes.
Output: A working `platform generate` command and a YAML-based template registry.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-platform-cli/DISCOVERY.md
@.planning/phases/02-platform-cli/02-01-SUMMARY.md
@pkg/scaffold/types.go
@pkg/scaffold/project.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template Configuration Management</name>
  <files>internal/templates/config.go, internal/templates/templates.yaml</files>
  <action>
    1. Create `internal/templates/templates.yaml` to define available templates (name, src, dest).
    2. Implement a config reader in `internal/templates/config.go` to parse this YAML.
    3. Update `pkg/scaffold` to use this dynamic configuration instead of hardcoded file lists.
  </action>
  <verify>
    Unit tests for config reader pass.
  </verify>
  <done>
    Template definitions are externalized to YAML.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate Command Implementation</name>
  <files>cmd/platform/generate.go</files>
  <action>
    1. Create `generate` command in `cmd/platform`.
    2. Define flags: `--project-name`, `--with-actions`, `--with-docker`, `--with-flux`, `--output`, `--force`, `--dry-run`.
    3. In `RunE`:
       - Map flags to `scaffold.Config`.
       - Call `scaffold.NewProjectGenerator().Generate(config)`.
       - Pass result to `writer.Write`.
  </action>
  <verify>
    `go run cmd/platform/main.go generate --help` shows flags.
  </verify>
  <done>
    Command exists and accepts flags.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration Verification</name>
  <files>cmd/platform/generate_test.go</files>
  <action>
    Write an integration test (or manual verify script) that runs the command with `--dry-run` and verifies output contains expected file paths.
  </action>
  <verify>
    `go test ./cmd/platform/...` passes.
  </verify>
  <done>
    Command correctly orchestrates Config -> Generator -> Writer.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go run cmd/platform/main.go generate --dry-run --project-name test` prints output
- [ ] Tests pass
</verification>

<success_criteria>
- [ ] Generate command functions end-to-end
- [ ] Flags map correctly to config
- [ ] Output is written (or simulated) via Writer
- [ ] Templates are loaded from YAML config
</success_criteria>

<output>
After completion, create `.planning/phases/02-platform-cli/02-02-SUMMARY.md`
</output>
